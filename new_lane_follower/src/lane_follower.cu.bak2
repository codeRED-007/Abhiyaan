#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/image.hpp"
#include "geometry_msgs/msg/point.hpp"
#include "bits/stdc++.h"
#include "opencv2/opencv.hpp"
#include "cv_bridge/cv_bridge.h"
// #include <mlpack/methods/dbscan/dbscan.hpp>
#include <mlpack/core.hpp>
#include "mlpack.hpp"
#include <armadillo>
#include <vector>
#include <pcl/point_types.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/io/pcd_io.h>
#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <Eigen/Dense>
#include "cuda_runtime.h"
#include "std_msgs/msg/string.hpp"
#include "std_msgs/msg/header.hpp"
#include "sensor_msgs/msg/camera_info.hpp"
#include "sensor_msgs/msg/point_cloud2.hpp"
#include "sensor_msgs/msg/point_field.hpp"
#include <math.h>
#include "geometry_msgs/msg/twist.hpp"
#include "nav_msgs/msg/odometry.hpp"
#include "std_msgs/msg/float32_multi_array.hpp"
#include "dbscan_cuda.cuh"
// #include "geometry_msgs/msg/pose_stamped.hpp"
// #include "nav2_util/lifecycle_service_client.hpp"
// #include "nav2_msgs/action/navigate_to_pose.hpp"
// #include "nav2_util/simple_action_server.hpp"
// #include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"

#define BLOCKS 1
#define imin(a,b) (a<b?a:b)

using namespace std;
using namespace std::chrono_literals;
using namespace std;
using namespace Eigen;
using std::placeholders::_1;

__global__ void dot(double* a, double* b, double* c, int rows) {
	int thread_id = threadIdx.x;
	int block_id = blockIdx.x;

	int offset = block_id*(rows+BLOCKS-1)/BLOCKS + thread_id;
	if(offset < rows){
		double temp=0;
		for(int i=0; i < 3; ++i){
		    temp += a[i]*b[offset*3+i];    
		}
		c[offset] = temp;
	}
	
	// debug
	// if(offset == 0){
	// 	for(int i=0;i < 3; ++i){
	// 		printf("gpu : %f ", c[0]);
	// 	}
	// 	printf("\n");
	// }

}


template<typename T>
__global__ void dev_matmul(const T *a, const T *b, T *output, int rows) {
    // a is 3x3 matrix
    // b is 3x1 set of matrices
    // output is 3x1 set of matrices
    int thread_id = threadIdx.x;
    int block_id = blockIdx.x;
    int offset = block_id * (rows + BLOCKS - 1) / BLOCKS + thread_id;

    if (offset < rows) {
        for (int i = 0; i < 3; ++i) {
            double temp = 0;
            for (int k = 0; k < 3; ++k) {
                temp += a[i * 3 + k] * b[offset * 3 + k];
            }
            output[offset * 3 + i] = temp;
        }
    }
}

void matmul(double *a, double *b, double *c){
	//a is 3x3
	//b is 3x1
	for(int i=0; i < 3; ++i){
		double temp=0;
		for(int k=0; k < 3; ++k){
			temp += a[i*3 + k]*b[k]; 
		}
		c[i] = temp;
	}
}



class LaneFollower : public rclcpp::Node
{
public:
    LaneFollower() : Node("lane_follower")
    {
        subscription = this->create_subscription<sensor_msgs::msg::Image>(
            "/zed/masked_image", 10, std::bind(&LaneFollower::binary_thresholding, this, std::placeholders::_1));
        
       
        subscription_caminfo = this->create_subscription<sensor_msgs::msg::CameraInfo>(
            "/zed/zed_node/rgb/camera_info", 10,
            std::bind(&LaneFollower::call, this, _1));
        publisher_far = this->create_publisher<sensor_msgs::msg::PointCloud2>("/far_ipm", 10);
        publisher_near = this->create_publisher<std_msgs::msg::Float32MultiArray>("/near_ipm", 10);

        db_publisher = this->create_publisher<sensor_msgs::msg::Image>("/dbImage", 10);
        db_publisher2 = this->create_publisher<sensor_msgs::msg::Image>("/dbImage2", 10);
        // m_publisher = this->create_publisher<geometry_msgs::msg::Point>("/flane/midpts/start", 10);
        vecto = this->create_publisher<geometry_msgs::msg::Point>("/vec", 10);
        cmd_vel_pub = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel", 10);


        subscription_odom = this->create_subscription<nav_msgs::msg::Odometry>(
            "/odom", 10,
            std::bind(&LaneFollower::call_odom, this, _1));
        // r_publisher = this->create_publisher<geometry_msgs::msg::Point>("/flane/rightpts/start", 10);
        // m_publisher = this->create_publisher<geometry_msgs::msg::Point>("/flane/midpts/start", 10);

        // ma_publisher = this->create_publisher<geometry_msgs::msg::Point>("/flane/align/start", 10);
        // ma2_publisher = this->create_publisher<geometry_msgs::msg::Point>("/flane/align/end", 10);
    }

private:

    void binary_thresholding(const sensor_msgs::msg::Image::SharedPtr msg)
    {   
        //cout<<" RECEIVED IMAGE"<<endl; 
        cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
        cv::Mat cv_image = cv_ptr->image, gray_image, thresholded_image;
        int rows = cv_image.rows;
        int cols = cv_image.cols;
        // cv_image = cv_image(cv::Range(rows/2,rows),cv::Range::all());
        cv::cvtColor(cv_image, gray_image,CV_BGR2GRAY); 
        //cout<<"BINARY THRESHOLDING STARTED"<<endl;
        cv::inRange(gray_image, 220, 255, thresholded_image);
        //cout<<"BINARY THRESHOLDING DONE"<<endl;

        
        std::vector<cv::Point> white_pixel_indices;

        // cv::findNonZero(thresholded_image, white_pixel_indices);
        

        // //cout<<"COLLECTING WHITE POINTS ENDED"<<endl;

        // arma::mat data(2, white_pixel_indices.size());
        
        // for (size_t i = 0; i < white_pixel_indices.size(); ++i) {
        //     data(0, i) = white_pixel_indices[i].x;
        //     data(1, i) = white_pixel_indices[i].y;
        // }

        // data.resize(2, (white_pixel_indices.size()+1)/2);

        // //cout<<white_pixel_indices.size()<<endl;
        // //cout<<"SETTING PARAMETERS FOR DB SCAN"<<endl;
        // // Parameters for DBSCAN
        // double epsilon = 5.0; // Adjust as needed
        // size_t minPoints = 10; // Adjust as needed
        int eps = 10;
        Graph graph(thresholded_image, eps);
        DBSCAN scanner(&graph, 0.1f, 10);
        scanner.identify_cluster();


        arma::Row<size_t> assignments;

// change later

        for (int i =0 ; i < graph.size() ; i++) {
            assignments[i] = scanner.label(i);
        }

        for (int i =0 ; i<graph.size() ; i++) {
            cv::Point point;
            point.x = graph.node(i).x;
            point.y = graph.node(i).y;

            white_pixel_indices.push_back(point);
        }


        //cout<<"DBSCAN STARTING"<<endl;
        // mlpack::dbscan::DBSCAN<> dbscan(epsilon, minPoints);
        // dbscan.Cluster(data, assignments);
        //cout<<"DBSCAN ENDED"<<endl;
        std::unordered_map<size_t, size_t> clusterSizes;

  // Count points in each cluster
        //cout <<"Count points in each cluster" <<endl;
        
        for (size_t i = 0; i < assignments.n_elem; ++i) {
            if (assignments[i] != SIZE_MAX) { // Ignore noise points
                clusterSizes[assignments[i]]++;
            }
        }

        //cout<<"Create a vector of pairs (clusterID, size) and sort it"<<endl;
        std::vector<std::pair<size_t, size_t>> sortedClusters(clusterSizes.begin(), clusterSizes.end());
        
        std::sort(sortedClusters.begin(), sortedClusters.end(), [](const std::pair<size_t, size_t>& a, const std::pair<size_t, size_t>& b) {
            return b.second < a.second; // Sort in descending order of size
        });
        
        

        if (sortedClusters.size() < 2) {
            RCLCPP_WARN(this->get_logger(), "Not enough clusters found");
            return;
        }

        if (!sortedClusters.empty()) {
            if (sortedClusters[0].second == 0) {
                //cout<<"No Clusters Found" <<endl;
                return;
            }
            largestClusterID = sortedClusters[0].first;
            SecondLargestClusterID = sortedClusters[1].first;


        }
        else {
            //cout<<"No sorted clusters"<<endl;
            return;
        }
        
        vector<cv::Point> largestCluster, secondLargestCluster;
        //cout<<"test"<<endl;
        for (size_t i = 0; i<assignments.n_elem ; ++i) {
            if (assignments[i] == largestClusterID) largestCluster.push_back(white_pixel_indices[i]);
            else if (assignments[i] == SecondLargestClusterID) secondLargestCluster.push_back(white_pixel_indices[i]);
        }
        

        
        cv::Mat dbImage = cv::Mat::zeros(gray_image.rows, gray_image.cols,CV_8UC1);
        cv::Mat dbImage2 = cv::Mat::zeros(gray_image.rows, gray_image.cols,CV_8UC1);

        

        for (cv::Point point : largestCluster) {
            dbImage.at<uchar>(point.y,point.x) = 255;
            dbImage2.at<uchar>(point.y,point.x) = 255;
            
        }

        for (cv::Point point : secondLargestCluster) {
            dbImage2.at<uchar>(point.y,point.x) = 255;
        }

        // for (size_t i = 0; i < assignments.n_elem; ++i) {
        //     //cout<<assignments[i]<<endl;
        // }
        // cv::imshow("Display Window",dbImage);
        // cv::waitKey(5);
        dbMsg = cv_bridge::CvImage(std_msgs::msg::Header(),"mono8",dbImage2).toImageMsg();
        db_publisher->publish(*dbMsg);
        
        midpoint_publisher(largestCluster,secondLargestCluster,dbImage2);
    

    }
    


    void midpoint_publisher(vector<cv::Point> largestCluster, vector<cv::Point> secondLargestCluster, cv::Mat lanes_binary) {

        geometry_msgs::msg::Point left,right,mid_farthest, mid_closest;
        int y__cord, x1__cord, x2__cord;

        bool midpoint_flag_farthest = false;
        bool midpoint_flag_closest = false;

        int current_y=0, prev_y=0;

        

        // Finding farthest point
        for (int j = 0 ; j<secondLargestCluster.size() ; j++) {
            current_y = secondLargestCluster[j].y;
            if (current_y != 0 && prev_y !=0 && current_y == prev_y) continue;  
            for (int i =0 ; i<largestCluster.size(); ++i) {
                if (largestCluster[i].y > secondLargestCluster[j].y) break;
                if ((largestCluster[i].y <= secondLargestCluster[j].y + 5)&&(largestCluster[i].y >= secondLargestCluster[j].y - 5)) {
                        
                        mid_farthest.y = largestCluster[i].y;
                        mid_farthest.x = (largestCluster[i].x + secondLargestCluster[j].x)/2;
                        midpoint_flag_farthest = true;
                        break;
                } 
            }
            if (midpoint_flag_farthest) break;
            prev_y = current_y;
        }

        // Finding Closest point

        current_y = 0;
        prev_y = 0;

        // std::sort(secondLargestCluster.end()-50, secondLargestCluster.end(), 
        //       [](const cv::Point& a, const cv::Point& b) {
        //           return a.y < b.y;
        //       });
        
        for (int j =secondLargestCluster.size() ; j>0 ; j--) {

            // cout <<secondLargestCluster[j] <<" "<< largestCluster[j]<<endl;

            current_y = secondLargestCluster[j].y;
            if (current_y != 0 && prev_y !=0 && current_y == prev_y) continue;  
            if ((current_y - mid_farthest.y)<10) continue;
            if (current_y ==0 ) continue;
            for (int i =largestCluster.size() ; i>0 ; i--) {
                if ((largestCluster[i].y <= secondLargestCluster[j].y + 5)&&(largestCluster[i].y >= secondLargestCluster[j].y - 5)) {

                        
                        y__cord = largestCluster[i].y;
                        x1__cord = largestCluster[i].x;
                        x2__cord = secondLargestCluster[j].x;

                        // cout<<" Y_coord "<<y__cord<<" "<<j<<endl;
                        
                        if (abs(x1__cord - x2__cord)>100 && y__cord != 0) {
                            mid_closest.y = y__cord;
                            mid_closest.x = (x1__cord + x2__cord)/2;
                            midpoint_flag_closest = true;
                            break;
                        }
                } 
            }
            if (midpoint_flag_closest) break;
            prev_y = current_y;
        }

        //cout<<midpoint_flag_farthest<<endl;
        if (midpoint_flag_farthest) {
            //cout<<"Y_COORDINATE "<<y__cord<<endl;
            lanes_binary.at<uchar>(mid_farthest.y,mid_farthest.x) = 255;
            
        }

        if (midpoint_flag_closest) {
            lanes_binary.at<uchar>(mid_closest.y,mid_closest.x) = 255;
        }

        // cv::imshow("window",lanes_binary);
        // cv::waitKey(30);
        // process_point(y__cord,(x1__cord+x2__cord)/2);

        cout << mid_farthest.x<<" "<<mid_farthest.y<<" "<<mid_closest.x<<" "<<mid_closest.y<<endl;
        // sensor_msgs::msg::PointCloud2 cloud_far = process_point(mid_farthest.y,mid_farthest.x);
        std_msgs::msg::Float32MultiArray cloud_near = process_point(mid_farthest.y,mid_farthest.x);
        // publisher_far -> publish(cloud_far);
        publisher_near -> publish(cloud_near);
        // publish_vect(mid_farthest,mid_closest);




        
        // cv:imshow("window",lanes_binary);
        // cv::waitKey(30);

        


    }
    void publish_vect(const geometry_msgs::msg::Point far_point,const geometry_msgs::msg::Point near_point ) {
        
        geometry_msgs::msg::Point vect;

        vect.x = far_point.x - near_point.x;
        vect.y = far_point.y - near_point.y;
        vect.z = 0;

        vecto->publish(vect);
        

    }


    void call(const sensor_msgs::msg::CameraInfo::SharedPtr msg) {
        this->camera_info = *msg;
    }
    void call_odom(const nav_msgs::msg::Odometry::SharedPtr msg) {
        this->odom = *msg;
        odom_received = true;

    }


    std_msgs::msg::Float32MultiArray process_point(int y, int x) {
        sensor_msgs::msg::PointCloud2 pub_pointcloud;
        auto cloud_msg = std::make_unique<PointCloud>();

        // Process the single point
        float roll = 0;
        float pitch = -24 * M_PI / 180;
        float yaw = 0;
        float h = 1.41;

        vector<double> k(9), nor(3), uv(3);

        double cy, cr, sy, sr, sp, cp;
        cy = cos(yaw);
        sy = sin(yaw);
        cp = cos(pitch);
        sp = sin(pitch);
        cr = cos(roll);
        sr = sin(roll);
        k[0] = cr * cy + sp * sr + sy;
        k[1] = cr * sp * sy - cy * sr;
        k[2] = -cp * sy;
        k[3] = cp * sr;
        k[4] = cp * cr;
        k[5] = sp;
        k[6] = cr * sy - cy * sp * sr;
        k[7] = -cr * cy * sp - sr * sy;
        k[8] = cp * cy;

        nor[0] = 0;
        nor[1] = 1.0;
        nor[2] = 0;

        // Calculate UV
        matmul(k.data(), nor.data(), uv.data()); // Nc - Normal in camera frame
        //cout<<"Normal Data "<<uv[0]<<" "<<uv[1]<<" "<<uv[2]<<endl;
        // Inverse camera matrix
        auto caminfo = this->camera_info.k;
        Eigen::Map<Matrix<double, 3, 3, RowMajor>> mat(caminfo.data());
        mat = mat.inverse();
        double *inv_caminfo = mat.data(); // K-1 (inverse of K)

        vector<double> kin_uv(3), denom(1);
        double *d_uv, *d_caminfo, *d_kin_uv, *d_denom, *d_nc;

        // Device allocations
        cudaMalloc((void**)&d_kin_uv, sizeof(double) * 3);
        cudaMalloc((void**)&d_caminfo, sizeof(double) * 9);
        cudaMalloc((void**)&d_denom, sizeof(double));
        cudaMalloc((void**)&d_nc, sizeof(double)*3);
        cudaMalloc((void**)&d_uv, sizeof(double)*3);

        // Prepare UV homogeneous coordinates
        double uv_hom[3] = { static_cast<double>(x), static_cast<double>(y), 1 };
        // vector<double> nc(3);
        //cout<<"Input Data "<<uv_hom[0]<<" "<<uv_hom[1]<<" "<<uv_hom[2]<<endl;
        // Copy to device
        cudaMemcpy(d_caminfo, inv_caminfo, sizeof(double) * 9, cudaMemcpyHostToDevice); // K-1 Matrix
        cudaMemcpy(d_uv, uv_hom, sizeof(double) * 3, cudaMemcpyHostToDevice); // Input data

        cudaMemcpy(d_nc, uv.data(), sizeof(double) * 3, cudaMemcpyHostToDevice);
        
        // cudaMemcpy(nc,d_nc,sizeof(double)*3, cudaMemcpyDeviceToHost);
        // //cout<<"Normal Data gpu "<<d_uv[0]<<" "<<d_uv[1]<<" "<<d_uv[2]<<endl;
        // Launch matrix multiplication
        dev_matmul<<<BLOCKS, 1>>>(d_caminfo, d_uv, d_kin_uv, 1); // K-1 x [x ,y, 1]
        
        cudaMemcpy(kin_uv.data(), d_kin_uv, sizeof(double) * 3, cudaMemcpyDeviceToHost); // K-1 x [x ,y, 1]
        // cout<<"Kin_uv Data "<<kin_uv[0]<<" "<<kin_uv[1]<<" "<<kin_uv[2]<<endl;
        // Calculate the denominator for the mapping
        dot<<<BLOCKS,1>>>(d_nc, d_kin_uv, d_denom, 1); // Nc * K-1 * [x, y, 1]
        // denom[0] = kin_uv[2];
        cudaMemcpy(denom.data(), d_denom, sizeof(double)*1, cudaMemcpyDeviceToHost);
	


        
        std::vector<float> vec(3);
        vec[0] = h * kin_uv[2] / denom[0];
        vec[1] = -h * kin_uv[0] / denom[0];
        vec[2] = 0;
        // cloud_msg->points.push_back(vec);

        // cout<<denom[0]<<endl;

        // Clean up
        cudaFree(d_kin_uv);
        cudaFree(d_caminfo);
        cudaFree(d_denom);
        cudaFree(d_nc);
        cudaFree(d_uv);

        pub_array.set__data(vec);

        // Prepare the PointCloud message for publishing
        // cloud_msg->height = 1;
        // cloud_msg->width = cloud_msg->points.size();
        // cloud_msg->is_dense = false;
        // pcl::toROSMsg(*cloud_msg, pub_pointcloud);
        // pub_pointcloud.header.frame_id = "base_link";
        // pub_pointcloud.header.stamp = rclcpp::Clock().now();

        

        // Publish the cloud
        // publisher_->publish(pub_pointcloud)
        return pub_array;



    }

 

// Start of Defining Variables ------------------------------------------------------------
    int largestClusterID=0, SecondLargestClusterID=0;
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription;
    // rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr subscription2;
    // // rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr l_publisher;
    // // rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr r_publisher;
    // rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr m_publisher;

    // rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr ma_publisher;
    // rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr ma2_publisher;
    rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr db_publisher;
    rclcpp::Publisher<sensor_msgs::msg::Image>::SharedPtr db_publisher2;

    sensor_msgs::msg::Image::SharedPtr dbMsg;
    sensor_msgs::msg::Image::SharedPtr dbMsg2;

    rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr m_publisher;
    rclcpp::Publisher<geometry_msgs::msg::Point>::SharedPtr vecto;
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_pub;

    rclcpp::Subscription<sensor_msgs::msg::CameraInfo>::SharedPtr subscription_caminfo;
    rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr subscription_odom;

    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr publisher_far;
    rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr publisher_near;

    sensor_msgs::msg::CameraInfo camera_info;
    nav_msgs::msg::Odometry odom;
    std_msgs::msg::Float32MultiArray pub_array;
    bool odom_received = false;
    typedef pcl::PointCloud<pcl::PointXYZ> PointCloud;

// End of Defining Variables

};




int main(int argc, char * argv[]) {
    rclcpp::init(argc, argv);
    auto lane_follower = std::make_shared<LaneFollower>();
    
    // Example: process a single point (x, y)
    // ipm_node->process_point(100, 150); // Replace (100, 150) with desired point coordinates
    
    rclcpp::spin(lane_follower);
    rclcpp::shutdown();
    return 0;
}

